---
timestamp: 'Fri Oct 24 2025 19:48:33 GMT-0400 (Eastern Daylight Time)'
parent: '[[..\20251024_194833.5ffe9980.md]]'
content_id: ca9742971983de126aeb1f015abb3e92f43235b7508d6a9bb1fbba0b9b8eea9f
---

# dayplanner.spec

\<concept\_spec>
concept DayPlanner

purpose
help organize activities for a single day

principle
activities are added one at a time, each with a title and duration;
activities are then assigned to time slots;
you can then use an LLM to assign any remaining unassigned activities
and view the resulting schedule

state
a set of Activity with
a title String
a duration Number // in half-hour units, so 3 is 90 mins
an optional startTime Number // in half-hour slots from midnight, so 14 is 7:00am

```
a set of Assignment with
    an Activity
    an startTime Number

invariants
    every assignment's activity is in the activity set
    there is at most one assignment per activity
    duration and startTime are between 0 and 47
```

actions\
addActivity(title: String, duration: Number): Activity
requires title is non-empty, duration is between 0 and 47
effect adds fresh activity with title and duration and returns it
note duration is measured in half hour increments, so 3 is 90 mins

```
removeActivity(activity: Activity)
    requires activity exists
    effect removes activity

assignActivity(activity: Activity, startTime: Number)
    requires activity exists and startTime is between 0 and 47
    effect adds fresh assignment for activity and startTime

unassignActivity(activity: Activity)
    requires assignment for activity exists
    effect removes assignment for activity

async assignActivities(llm: GeminiLLM)
    effect uses llm to assign all unassigned activities    
```

notes
This is a very rudimentary concept to demonstrate how to use an LLM.

\</concept\_spec>

**concept** Annotation \[User, Document]

**purpose** allow users to create annotations within documents and search amongst their annotations

**principle** When users read a document, they can create and view highlighting or text annotations in the document. Users can label annotations with tags. Users can also search for annotations in a document with specific keywords or about certain ideas.

**state**\
a set of Annotations with:

* a creator User
* a document Document
* an optional color String
* an optional content String
* a location String
* a tags set of Tags

a set of Tags with:

* a creator User
* a title String

a set of Documents with:

* an annotations set of Annotations
* a creator User

**actions**

createTag(creator: User, title: String): (tag: Tag)

* **requires** a tag with user and title does not already exist
* **effects** creates a tag with title

createAnnotation(creator: User, document: Document, color: String, content: String, location: String, tags: List\[Tag]): (annotation: Annotation)

* **requires**
  * document exists, and has creator=creator
  * location exists and is a well-defined CFI
  * color is either a valid HTML color, or omitted. At least one of color and content must not be omitted
* **effects**
  * creates and adds annotation with creator, document, color, content, location, and tags to the set of Annotations.
  * Adds annotation to the document's set of annotations

deleteAnnotation(user: User, annotation: Annotation)

* **requires** annotation exists and has creator=user
* **effects** removes annotation from all sets of Annotations

updateAnnotation(user: User, annotation: Annotation, newColor: String, newContent: String, newLocation: String, newTags: List\[Tag]): (annotation: Annotation)

* **requires** annotation has creator=user, newColor (if provided) is a valid HTML color. Any of newColor, newContent, newLocation, and newTags may be omitted.
* **effects** modifies annotation to have color=newColor, content=newContent, location=newLocation, tags=newTags (for each attribute that is not omitted)

search(user: User, document: Document, criteria: String): (annotations: List\[Annotations\\])

* **requires** document exists
* **effects** returns a list of annotations with creator=user in the document that have content or tags matching criteria

**notes:**

* Locations should be CFI strings (Canonical Fragment Identifiers, compatible with many epub libraries)
