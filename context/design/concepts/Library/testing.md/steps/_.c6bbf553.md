---
timestamp: 'Thu Oct 23 2025 02:00:15 GMT-0400 (Eastern Daylight Time)'
parent: '[[..\20251023_020015.92f93fd5.md]]'
content_id: c6bbf553272493d58891dbc6a0b94ade3d4e6b61a3b31813373769563cac6bf0
---

# dayplanner.spec

\<concept\_spec>
concept DayPlanner

purpose
help organize activities for a single day

principle
activities are added one at a time, each with a title and duration;
activities are then assigned to time slots;
you can then use an LLM to assign any remaining unassigned activities
and view the resulting schedule

state
a set of Activity with
a title String
a duration Number // in half-hour units, so 3 is 90 mins
an optional startTime Number // in half-hour slots from midnight, so 14 is 7:00am

```
a set of Assignment with
    an Activity
    an startTime Number

invariants
    every assignment's activity is in the activity set
    there is at most one assignment per activity
    duration and startTime are between 0 and 47
```

actions\
addActivity(title: String, duration: Number): Activity
requires title is non-empty, duration is between 0 and 47
effect adds fresh activity with title and duration and returns it
note duration is measured in half hour increments, so 3 is 90 mins

```
removeActivity(activity: Activity)
    requires activity exists
    effect removes activity

assignActivity(activity: Activity, startTime: Number)
    requires activity exists and startTime is between 0 and 47
    effect adds fresh assignment for activity and startTime

unassignActivity(activity: Activity)
    requires assignment for activity exists
    effect removes assignment for activity

async assignActivities(llm: GeminiLLM)
    effect uses llm to assign all unassigned activities    
```

notes
This is a very rudimentary concept to demonstrate how to use an LLM.

\</concept\_spec>

**concept** Library \[User]

**purpose** allow users to add, remove, view, and access their uploaded documents

**principle** A user can upload documents (.epub) to their library, view all of their uploaded documents, and remove or open and read any of the documents in their library.

**state**\
a set of Libraries with:

* a user User
* a documents set of Documents

a set of Documents with:

* a name String
* an epubContent BinaryData

**actions**\
createLibrary(user: User): (library: Library)

* **requires** user is not already associated with a library
* **effects** creates a new library with user and an empty set of documents

removeDocument(library: Library, document: Document)

* **requires** library exists and document is in library
* **effects** removes document from the set of documents and from library's documents set

createDocument(name: String, epubContent: BinaryData, library: Library): (document: Document)

* **requires** a document with name does not already exist in the given library
* **effects** creates a new Document with name and file and adds it to library

renameDocument(user: User, newName: String, document: Document): (document: Document)

* **requires** document has user=user and newName is not the name of an existing document with user=user
* **effect** changes document's name to newName

openDocument(user: User, document: Document): (document: Document)

* **requires** user is in a library with document

closeDocument(user: User, document: Document): (document: Document)

* **requires** user is in a library with document

**Notes**

* This concept allows a user to have multiple uploads/documents of the same underlying epubContent/BinaryData, so long as they are given different names.
* Invariant: There will be no two libraries with the same user
* Invariant: all documents have unique names
* Each document is in and belongs to exactly 1 library
* epubContent is represented as a BinaryData rather than its own complex since .epub files will be interacted with via a library that treats them as their own data type
