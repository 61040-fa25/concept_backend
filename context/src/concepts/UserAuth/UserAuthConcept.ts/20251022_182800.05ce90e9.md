---
timestamp: 'Wed Oct 22 2025 18:28:00 GMT-0400 (Eastern Daylight Time)'
content_id: 05ce90e94a5e8b3ea97f926f0892407cb1220721f9ac829ea6ef4ab4c443a595
---

# file: src\concepts\UserAuth\UserAuthConcept.ts

```typescript
import { Collection, Db } from "npm:mongodb";
import { Empty, ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";

// Collection prefix to ensure namespace separation
const PREFIX = "UserAuth" + ".";

// Generic types for the concept's external dependencies
type User = ID; // Represents a user ID

/**
 * State: A set of Users, each with an email, username, password, confirmation status, and a confirmation token.
 * Note: In a real-world scenario, the 'password' field would store a hashed password,
 * and 'confirmationToken' would ideally have an expiration date.
 */
interface UserDoc {
  _id: User;
  email: string;
  username: string;
  password: string; // In a real system, this would be a hashed password.
  confirmed: boolean;
  confirmationToken: string | null; // Token used for email confirmation, null after confirmation or if not needed.
}

/**
 * @concept UserAuthentication
 * @purpose To limit access to known users.
 * @principle After a user registers with a username and a password, they can
 *            authenticate with that same username and password and be treated
 *            each time as the same user.
 */
export default class UserAuthConcept {
  users: Collection<UserDoc>;

  constructor(private readonly db: Db) {
    this.users = this.db.collection(PREFIX + "users");
  }

  /**
   * Action: Registers a new user.
   * register (username: String, password: String, email: String): (user: User) (token: String)
   *
   * @requires A unique username.
   *
   * @effects Creates a User with the associated username and password. Creates a new
   *          token for email verification. The 'confirmed' flag is set to false.
   *          Returns the new User's ID and the generated confirmation token.
   */
  async register(
    { username, password, email }: {
      username: string;
      password: string;
      email: string;
    },
  ): Promise<{ user: User; token: string } | { error: string }> {
    const existingUser = await this.users.findOne({ username });
    if (existingUser) {
      return { error: `Username '${username}' is already taken.` };
    }

    const userId = freshID() as User;
    // In a real application, 'password' would be hashed here.
    // e.g., const hashedPassword = await hashPassword(password);

    // Generate a simple token for demonstration. In production, use a secure, unique token.
    const confirmationToken = freshID() as string;

    await this.users.insertOne({
      _id: userId,
      email,
      username,
      password, // Storing plaintext for conceptual example, but should be hashed.
      confirmed: false,
      confirmationToken,
    });

    return { user: userId, token: confirmationToken };
  }

  /**
   * Action: Confirms a user's email address using a provided token.
   * confirm (username: String, token: String): Empty | { error: string }
   *
   * @effects If the token matches the username's associated User, the 'confirmed'
   *          flag changes to true. Otherwise, 'confirmed' stays false.
   */
  async confirm(
    { username, token }: { username: string; token: string },
  ): Promise<Empty | { error: string }> {
    const user = await this.users.findOne({ username });

    if (!user) {
      return { error: `User with username '${username}' not found.` };
    }

    if (user.confirmed) {
      return { error: `User '${username}' is already confirmed.` };
    }

    if (user.confirmationToken === token) {
      await this.users.updateOne(
        { _id: user._id },
        { $set: { confirmed: true, confirmationToken: null } }, // Clear token after use
      );
      return {};
    } else {
      return { error: "Invalid confirmation token." };
    }
  }

  /**
   * Action: Authenticates a user with a username and password.
   * authenticate (username: String, password: String): (user: User) | { error: string }
   *
   * @requires User's 'confirmed' flag must be true and username and password must match
   *           internal record for the user.
   *
   * @effects If the user is authenticated, returns the user's ID. If not, returns an error.
   */
  async authenticate(
    { username, password }: { username: string; password: string },
  ): Promise<{ user: User } | { error: string }> {
    const user = await this.users.findOne({ username });

    if (!user) {
      return { error: "Invalid username or password." };
    }

    if (!user.confirmed) {
      return { error: "User email not confirmed. Please check your email." };
    }

    // In a real application, 'password' would be compared with a hashed password.
    // e.g., const passwordMatches = await comparePasswords(password, user.passwordHash);
    if (user.password === password) { // Conceptual comparison, should be hash comparison.
      return { user: user._id };
    } else {
      return { error: "Invalid username or password." };
    }
  }

  /**
   * Query: Retrieves a user by their username.
   * This is an internal query useful for testing or other internal operations.
   */
  async _getUserByUsername(
    { username }: { username: string },
  ): Promise<UserDoc | null> {
    return await this.users.findOne({ username });
  }

  /**
   * Query: Retrieves a user by their ID.
   * This is an internal query useful for testing or other internal operations.
   */
  async _getUserById({ userId }: { userId: User }): Promise<UserDoc | null> {
    return await this.users.findOne({ _id: userId });
  }
}

```
