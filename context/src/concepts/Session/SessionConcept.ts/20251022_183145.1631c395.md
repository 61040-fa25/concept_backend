---
timestamp: 'Wed Oct 22 2025 18:31:45 GMT-0400 (Eastern Daylight Time)'
content_id: 1631c3954bf998d07d4087ca6acc70dc685a70970cbd59af7f8b87010896d8ad
---

# file: src\concepts\Session\SessionConcept.ts

```typescript
import { Collection, Db } from "npm:mongodb";
import { Empty, ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";

// Collection prefix to ensure namespace separation
const PREFIX = "UserSession" + ".";

// Generic types for the concept's external dependencies
type UserID = ID;

// Internal entity types, represented as IDs
type Session = ID;

// Default session duration in milliseconds (e.g., 30 minutes)
const DEFAULT_SESSION_DURATION_MS = 30 * 60 * 1000;

/**
 * State: A set of sessions with a userID and an expiry time.
 */
interface SessionDoc {
  _id: Session;
  userID: UserID;
  expiryTime: Date;
}

/**
 * @concept UserSession
 * @purpose Enables the user to stay logged in during an interaction period so they can perform actions without authenticating each time.
 * @principle The user is successfully authenticated, and a session is created and associated with the user.
 *            The user can extend their session or explicitly end it or allow it to expire after a fixed duration.
 */
export default class UserSessionConcept {
  sessions: Collection<SessionDoc>;

  constructor(private readonly db: Db) {
    this.sessions = this.db.collection(PREFIX + "sessions");
  }

  /**
   * Action: Starts a new user session.
   * startSession ( u : userID) : ( s : session)
   * @requires A valid authenticated user. (This concept assumes UserID validity is handled externally)
   * @effects Creates a session associated with the user and an expiry time; returns the new session ID.
   */
  async startSession(
    { u }: { u: UserID },
  ): Promise<{ session: Session }> {
    const sessionId = freshID() as Session;
    const expiryTime = new Date(Date.now() + DEFAULT_SESSION_DURATION_MS);

    await this.sessions.insertOne({
      _id: sessionId,
      userID: u,
      expiryTime,
    });
    return { session: sessionId };
  }

  /**
   * Action: Ends an existing user session.
   * endSession ( s : session)
   * @requires The session must be valid (exist).
   * @effects Deletes the session from the state.
   */
  async endSession(
    { s }: { s: Session },
  ): Promise<Empty | { error: string }> {
    const result = await this.sessions.deleteOne({ _id: s });

    if (result.deletedCount === 0) {
      return { error: `Session with ID ${s} not found.` };
    }

    return {};
  }

  /**
   * Action: Verifies if a session is still active and unexpired, allowing the user to proceed.
   * useSession (s : session)
   * @requires The session must not be expired.
   * @effects Allows the user to proceed as an authenticated user (no state change by this action).
   */
  async useSession(
    { s }: { s: Session },
  ): Promise<Empty | { error: string }> {
    const sessionDoc = await this.sessions.findOne({ _id: s });

    if (!sessionDoc) {
      return { error: `Session with ID ${s} not found.` };
    }

    if (sessionDoc.expiryTime <= new Date()) {
      return { error: `Session with ID ${s} has expired.` };
    }

    // Session is valid and not expired. User can proceed.
    return {};
  }

  /**
   * Action: Extends the validity of an existing session by deleting it and creating a new one.
   * extendSession (s : session)
   * @requires The session must be valid (exist and not expired).
   * @effects Deletes the old session and creates a new session for that user with an updated expiry time, returning the new session ID.
   */
  async extendSession(
    { s }: { s: Session },
  ): Promise<{ session: Session } | { error: string }> {
    const sessionDoc = await this.sessions.findOne({ _id: s });

    if (!sessionDoc) {
      return { error: `Session with ID ${s} not found.` };
    }

    if (sessionDoc.expiryTime <= new Date()) {
      return {
        error: `Session with ID ${s} has expired and cannot be extended.`,
      };
    }

    // Delete the old session
    await this.sessions.deleteOne({ _id: s });

    // Create a new session with updated expiry for the same user
    const newSessionId = freshID() as Session;
    const newExpiryTime = new Date(Date.now() + DEFAULT_SESSION_DURATION_MS);

    await this.sessions.insertOne({
      _id: newSessionId,
      userID: sessionDoc.userID,
      expiryTime: newExpiryTime,
    });

    return { session: newSessionId };
  }

  /**
   * Action: System-level action to expire sessions that have passed their expiry time.
   * System expire ()
   * @requires Sessions have passed their expiry time.
   * @effects Deletes all sessions that have passed their expiry time.
   */
  async _expireSessions(): Promise<Empty> {
    const now = new Date();
    await this.sessions.deleteMany({ expiryTime: { $lte: now } });
    return {};
  }

  /**
   * Query: Retrieves all active sessions for a specific user.
   * _getUserSessions (u: UserID): (session: SessionDoc)
   */
  async _getUserSessions(
    { u }: { u: UserID },
  ): Promise<SessionDoc[]> {
    const now = new Date();
    return await this.sessions.find({ userID: u, expiryTime: { $gt: now } })
      .toArray();
  }

  /**
   * Query: Retrieves a specific session document.
   * _getSession (s: Session): (session: SessionDoc)
   */
  async _getSession(
    { s }: { s: Session },
  ): Promise<SessionDoc | null> {
    return await this.sessions.findOne({ _id: s });
  }
}

```
