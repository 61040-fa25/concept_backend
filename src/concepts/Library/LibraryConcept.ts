import { Collection, Db } from "npm:mongodb";
import { Empty, ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";

// Declare collection prefix, use concept name
const PREFIX = "Library" + ".";

// Generic types of this concept
type User = ID;
type LibraryID = ID; // Renamed to LibraryID to avoid conflict with Collection name
type DocumentID = ID; // Renamed to DocumentID to avoid conflict with Collection name

/**
 * State: a set of Libraries with:
 *   a user User
 *   a documents set of Documents
 */
interface LibraryDoc {
  _id: LibraryID;
  user: User;
  documents: DocumentID[];
}

/**
 * State: a set of Documents with:
 *   a name String
 *   an epubContent BinaryData (represented as a string, e.g., base64 encoded data or a URL)
 */
interface DocumentDoc {
  _id: DocumentID;
  name: string;
  epubContent: string; // Assuming BinaryData is stored as a base64 string or a similar string representation
}

/**
 * Library concept:
 *
 * purpose:
 * allow users to add, remove, view, and access their uploaded documents
 *
 * principle:
 * A user can upload documents (.epub) to their library, view all of their uploaded documents,
 * and remove or open and read any of the documents in their library.
 *
 * Notes:
 * - This concept allows a user to have multiple uploads/documents of the same underlying epubContent/BinaryData,
 *   so long as they are given different names within the same library.
 * - Invariant: There will be no two libraries with the same user.
 * - Invariant: Document names are unique within a single library.
 * - Invariant: Each document, once created, is associated with exactly one library.
 * - epubContent is represented as a BinaryData (string) rather than its own complex type,
 *   as .epub files will likely be interacted with via a library that treats them as their own data type.
 */

export default class LibraryConcept {
  libraries: Collection<LibraryDoc>;
  documents: Collection<DocumentDoc>;

  constructor(private readonly db: Db) {
    this.libraries = this.db.collection(PREFIX + "libraries");
    this.documents = this.db.collection(PREFIX + "documents");
  }

  /**
   * createLibrary (user: User): (library: LibraryID)
   *
   * **requires** user is not already associated with a library
   *
   * **effects** creates a new library with user and an empty set of documents; returns the new library's ID
   */
  async createLibrary(
    { user }: { user: User },
  ): Promise<{ library?: LibraryID; error?: string }> {
    // Check precondition: user is not already associated with a library
    const existingLibrary = await this.libraries.findOne({ user });
    if (existingLibrary) {
      return { error: `User ${user} already has a library.` };
    }

    const newLibraryId = freshID() as LibraryID;
    const newLibrary: LibraryDoc = {
      _id: newLibraryId,
      user: user,
      documents: [],
    };

    await this.libraries.insertOne(newLibrary);
    return { library: newLibraryId };
  }

  /**
   * removeDocument (library: LibraryID, document: DocumentID): Empty
   *
   * **requires** library exists and document is in library
   *
   * **effects** removes document from the set of documents and from library's documents set
   */
  async removeDocument(
    { library, document }: { library: LibraryID; document: DocumentID },
  ): Promise<Empty | { error: string }> {
    // Check precondition: library exists
    const existingLibrary = await this.libraries.findOne({ _id: library });
    if (!existingLibrary) {
      return { error: `Library ${library} does not exist.` };
    }

    // Check precondition: document is in library
    if (!existingLibrary.documents.includes(document)) {
      return { error: `Document ${document} is not in library ${library}.` };
    }

    // Effect: remove document from the library's documents set
    await this.libraries.updateOne(
      { _id: library },
      { $pull: { documents: document } },
    );

    // Effect: remove document from the documents collection
    await this.documents.deleteOne({ _id: document });

    return {};
  }

  /**
   * createDocument (name: String, epubContent: BinaryData, library: LibraryID): (document: DocumentID)
   *
   * **requires** library exists and a document with `name` does not already exist in the given `library`
   *
   * **effects** creates a new Document with `name` and `epubContent` and adds it to the `library`; returns the new document's ID
   */
  async createDocument(
    { name, epubContent, library }: {
      name: string;
      epubContent: string;
      library: LibraryID;
    },
  ): Promise<{ document?: DocumentID; error?: string }> {
    // Check precondition: library exists
    const existingLibrary = await this.libraries.findOne({ _id: library });
    if (!existingLibrary) {
      return { error: `Library ${library} does not exist.` };
    }

    // Check precondition: a document with name does not already exist in the given library
    // Query for documents whose IDs are in the library's document list AND have the given name.
    const nameExistsInLibrary = await this.documents.findOne({
      _id: { $in: existingLibrary.documents },
      name: name,
    });

    if (nameExistsInLibrary) {
      return {
        error:
          `Document with name '${name}' already exists in library ${library}.`,
      };
    }

    const newDocumentId = freshID() as DocumentID;
    const newDocument: DocumentDoc = {
      _id: newDocumentId,
      name,
      epubContent,
    };

    // Effect: creates a new Document
    await this.documents.insertOne(newDocument);

    // Effect: adds it to library's documents set
    await this.libraries.updateOne(
      { _id: library },
      { $push: { documents: newDocumentId } },
    );

    return { document: newDocumentId };
  }

  /**
   * renameDocument (user: User, newName: String, document: DocumentID): (document: DocumentID)
   *
   * **requires** document exists and is associated with a library owned by `user`,
   *              and `newName` is not the name of an existing document within that user's library (excluding the document being renamed)
   *
   * **effects** changes document's name to `newName`; returns the document's ID
   */
  async renameDocument(
    { user, newName, document }: {
      user: User;
      newName: string;
      document: DocumentID;
    },
  ): Promise<{ document?: DocumentID; error?: string }> {
    // Check precondition: document exists
    const existingDocument = await this.documents.findOne({ _id: document });
    if (!existingDocument) {
      return { error: `Document ${document} does not exist.` };
    }

    // Find the library owned by the user
    const userLibrary = await this.libraries.findOne({ user });
    if (!userLibrary) {
      return { error: `User ${user} does not have a library.` };
    }

    // Check precondition: document is associated with user's library
    if (!userLibrary.documents.includes(document)) {
      return {
        error: `Document ${document} is not in user ${user}'s library.`,
      };
    }

    // Check precondition: newName is not the name of an existing document in this library (excluding the document itself)
    const nameExistsInLibrary = await this.documents.findOne({
      _id: { $in: userLibrary.documents, $ne: document }, // documents in library, but not the current document
      name: newName,
    });

    if (nameExistsInLibrary) {
      return {
        error:
          `Document with name '${newName}' already exists in user ${user}'s library.`,
      };
    }

    // Effect: changes document's name to newName
    await this.documents.updateOne(
      { _id: document },
      { $set: { name: newName } },
    );

    return { document: document };
  }

  /**
   * openDocument (user: User, document: DocumentID): (document: DocumentID)
   *
   * **requires** user is in a library with `document`
   *
   * **effects** confirms the document is accessible to the user; returns the document's ID.
   *            (Note: The concept state does not explicitly track an "open" status,
   *             so this action primarily serves to validate access for the user.)
   */
  async openDocument(
    { user, document }: { user: User; document: DocumentID },
  ): Promise<{ document?: DocumentID; error?: string }> {
    // Find the library owned by the user
    const userLibrary = await this.libraries.findOne({ user });
    if (!userLibrary) {
      return { error: `User ${user} does not have a library.` };
    }

    // Check precondition: document exists and is in user's library
    const docExists = await this.documents.findOne({ _id: document });
    if (!docExists || !userLibrary.documents.includes(document)) {
      return {
        error:
          `Document ${document} does not exist or is not in user ${user}'s library.`,
      };
    }

    // As no state for "open" is defined, the effect is implicit confirmation of access.
    // In a full application, this might trigger content loading, logging, etc.
    return { document: document };
  }

  /**
   * closeDocument (user: User, document: DocumentID): (document: DocumentID)
   *
   * **requires** user is in a library with `document`
   *
   * **effects** confirms the document is no longer actively being accessed by the user; returns the document's ID.
   *            (Note: Similar to `openDocument`, this action primarily validates user-document association
   *             as no specific "close" state is defined in the concept.)
   */
  async closeDocument(
    { user, document }: { user: User; document: DocumentID },
  ): Promise<{ document?: DocumentID; error?: string }> {
    // Find the library owned by the user
    const userLibrary = await this.libraries.findOne({ user });
    if (!userLibrary) {
      return { error: `User ${user} does not have a library.` };
    }

    // Check precondition: document exists and is in user's library
    const docExists = await this.documents.findOne({ _id: document });
    if (!docExists || !userLibrary.documents.includes(document)) {
      return {
        error:
          `Document ${document} does not exist or is not in user ${user}'s library.`,
      };
    }

    // As no state for "close" is defined, the effect is implicit confirmation of closure.
    return { document: document };
  }

  // --- Queries (not explicitly in concept spec, but useful for interaction and testing) ---

  /**
   * _getLibraryByUser (user: User): (library: LibraryDoc)
   *
   * **requires** user exists and has a library
   *
   * **effects** returns the library document associated with the user
   */
  async _getLibraryByUser(
    { user }: { user: User },
  ): Promise<{ library?: LibraryDoc; error?: string }[]> {
    const library = await this.libraries.findOne({ user });
    if (!library) {
      return [{ error: `No library found for user ${user}.` }];
    }
    return [{ library: library }];
  }

  /**
   * _getDocumentsInLibrary (library: LibraryID): (document: DocumentDoc)
   *
   * **requires** library exists
   *
   * **effects** returns all documents (including their name and epub content) that are part of the given library
   */
  async _getDocumentsInLibrary(
    { library }: { library: LibraryID },
  ): Promise<{ document?: DocumentDoc; error?: string }[]> {
    const existingLibrary = await this.libraries.findOne({ _id: library });
    if (!existingLibrary) {
      return [{ error: `Library ${library} does not exist.` }];
    }

    const documents = await this.documents.find({
      _id: { $in: existingLibrary.documents },
    }).toArray();
    return documents.map((doc) => ({ document: doc }));
  }

  /**
   * _getDocumentDetails (document: DocumentID): (document: DocumentDoc)
   *
   * **requires** document exists
   *
   * **effects** returns the details (name, epubContent) of the specified document
   */
  async _getDocumentDetails(
    { document }: { document: DocumentID },
  ): Promise<{ document?: DocumentDoc; error?: string }[]> {
    const doc = await this.documents.findOne({ _id: document });
    if (!doc) {
      return [{ error: `Document ${document} does not exist.` }];
    }
    return [{ document: doc }];
  }
}
