import { Collection, Db } from "npm:mongodb";
import { Empty, ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";
import { compare, hash } from "npm:bcryptjs";

const PREFIX = "Profile" + ".";
type User = ID;

interface UserDocument {
  _id: User;
  username: string;
  passwordHash: string;
}

/**
 * Profile Concept
 *
 * **purpose** collect basic authentication and user info
 *
 * **principle** A user can create an account and sign in with a username/password.
 * Users can also change their password.
 */
export default class ProfileConcept {
  private users: Collection<UserDocument>;
  private readonly SALT_ROUNDS = 10;

  constructor(private readonly db: Db) {
    this.users = this.db.collection(PREFIX + "users");
  }

  // --- NEW METHOD FOR TESTING ---
  /**
   * Clears all collections managed by the ProfileConcept.
   * This is primarily for testing purposes to ensure a clean state before each test.
   */
  async clearCollections(): Promise<void> {
    await this.users.deleteMany({});
  }
  // --- END NEW METHOD ---

  /**
   * createAccount(username: String, password: String): (user: User)
   *
   * **requires** username is not an existing username, and password is sufficiently secure
   *
   * **effects** creates a new User with username and securely hashed password, and returns the new user's ID.
   */
  async createAccount(
    { username, password }: { username: string; password: string },
  ): Promise<{ user: User } | { error: string }> {
    const existingUser = await this.users.findOne({ username });
    if (existingUser) {
      return { error: `Username '${username}' already exists.` };
    }

    if (password.length < 8) {
      return { error: "Password must be at least 8 characters long." };
    }

    const passwordHash = await hash(password, this.SALT_ROUNDS);

    const newUser: UserDocument = {
      _id: freshID() as User,
      username,
      passwordHash,
    };

    await this.users.insertOne(newUser);
    return { user: newUser._id };
  }

  /**
   * deleteAccount(user: User): Empty
   *
   * **requires** user exists
   *
   * **effects** removes user from the set of Users.
   */
  async deleteAccount(
    { user }: { user: User },
  ): Promise<Empty | { error: string }> {
    const existingUser = await this.users.findOne({ _id: user });
    if (!existingUser) {
      return { error: `User '${user}' not found.` };
    }

    await this.users.deleteOne({ _id: user });
    return {};
  }

  /**
   * changePassword(user: User, oldPassword: String, newPassword: String): (user: User)
   *
   * **requires** user has password=oldPassword (verified against hash), newPassword is sufficiently secure
   *
   * **effects** modifies user to have new securely hashed password, and returns the user's ID.
   */
  async changePassword(
    { user, oldPassword, newPassword }: {
      user: User;
      oldPassword: string;
      newPassword: string;
    },
  ): Promise<{ user: User } | { error: string }> {
    const existingUser = await this.users.findOne({ _id: user });
    if (!existingUser) {
      return { error: `User '${user}' not found.` };
    }

    const isOldPasswordCorrect = await compare(
      oldPassword,
      existingUser.passwordHash,
    );
    if (!isOldPasswordCorrect) {
      return { error: "Incorrect old password." };
    }

    if (newPassword.length < 8) {
      return { error: "New password must be at least 8 characters long." };
    }

    const isNewPasswordSameAsOld = await compare(
      newPassword,
      existingUser.passwordHash,
    );
    if (isNewPasswordSameAsOld) {
      return { error: "New password cannot be the same as the old password." };
    }

    const newPasswordHash = await hash(newPassword, this.SALT_ROUNDS);

    await this.users.updateOne(
      { _id: user },
      { $set: { passwordHash: newPasswordHash } },
    );

    return { user };
  }

  /**
   * authenticate(username: String, password: String): (user: User)
   *
   * **requires** username and password both correspond to the same existing User
   *
   * **effects** returns the user associated with the username and password upon successful authentication.
   */
  async authenticate(
    { username, password }: { username: string; password: string },
  ): Promise<{ user: User } | { error: string }> {
    const userDoc = await this.users.findOne({ username });

    if (!userDoc || !(await compare(password, userDoc.passwordHash))) {
      return { error: "Invalid username or password." };
    }

    return { user: userDoc._id };
  }

  /**
   * _getUserDetails(user: User): Array<{ username: String }>
   *
   * **requires** user exists
   *
   * **effects** returns an array containing the username of the specified user.
   *             (Password hash is NOT exposed by this query).
   */
  async _getUserDetails(
    { user }: { user: User },
  ): Promise<Array<{ username: string }> | { error: string }> {
    const userDoc = await this.users.findOne({ _id: user });
    if (!userDoc) {
      return { error: `User '${user}' not found.` };
    }
    return [{ username: userDoc.username }];
  }

  /**
   * _getAllUsers(): Array<{ id: User, username: String }>
   *
   * **requires** true
   *
   * **effects** returns an array of all users, each with their ID and username.
   */
  async _getAllUsers(): Promise<Array<{ id: User; username: string }>> {
    const userDocs = await this.users.find().toArray();
    return userDocs.map((u) => ({ id: u._id, username: u.username }));
  }
}
