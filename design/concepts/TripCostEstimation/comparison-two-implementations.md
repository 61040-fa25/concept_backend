# another concept implementation:
``` typescript
/**

Â * TripCostEstimation Concept - AI Augmented Version

Â *

Â * Generates realistic cost estimates for travel plans using AI for data retrieval and calculation

Â */

  

import { GeminiLLM } from './gemini-llm';

  

// Cost validation constants

const MAXCOST = 1e6; Â // $1,000,000 - maximum reasonable cost for any travel component

const MINCOST = 0; Â  Â // $0 - minimum cost (free)

  

// User is just an identifier following modularity principles

export type User = number;

  

// Location represents a city

export interface Location {

Â  Â  city: string;

}

  

// Travel plan with dates and necessities

export interface TravelPlan {

Â  Â  id: string;

Â  Â  user: User;

Â  Â  fromCity: Location;

Â  Â  toCity: Location;

Â  Â  fromDate: Date;

Â  Â  toDate: Date;

Â  Â  necessity: Necessity;

}

  

// Necessity preferences for accommodation and dining

export interface Necessity {

Â  Â  accommodation: boolean; // true for saving for rooms, false for not

Â  Â  diningFlag: boolean; Â  Â // true for saving for eating out, false for not

}

  

// Cost estimate generated by AI

export interface CostEstimate {

Â  Â  travelPlanID: string;

Â  Â  flight: number; Â  Â  Â  Â  // estimated total round-trip flight cost in USD

Â  Â  roomsPerNight: number; Â // estimated cost per night in USD

Â  Â  foodDaily: number; Â  Â  Â // estimated cost per day in USD

Â  Â  lastUpdated: Date; Â  Â  Â // tracking when the estimate was generated

}

  

export class TripCostEstimation {

Â  Â  private travelPlans: TravelPlan[] = [];

Â  Â  private costEstimates: CostEstimate[] = [];

Â  Â  private nextPlanId = 1;

  

Â  Â  /**

Â  Â  Â * Create a new travel plan for a user

Â  Â  Â * @requires fromCity.city !== toCity.city (different cities required)

Â  Â  Â * Â  Â  Â  Â  toDate >= fromDate (return date must be on or after departure date)

Â  Â  Â * Â  Â  Â  Â  fromDate > new Date() (departure date must be in the future)

Â  Â  Â * Â  Â  Â  Â  toDate > new Date() (return date must be in the future)

Â  Â  Â * @returns TravelPlan with unique ID, user, cities, dates, and default necessity (accommodation: true, diningFlag: true)

Â  Â  Â */

Â  Â  createTravelPlan(user: User, fromCity: Location, toCity: Location, fromDate: Date, toDate: Date): TravelPlan {

Â  Â  Â  Â  // Validate requirements

Â  Â  Â  Â  if (toDate < fromDate) {

Â  Â  Â  Â  Â  Â  throw new Error('toDate must be on or after fromDate');

Â  Â  Â  Â  }

Â  Â  Â  Â  if (fromDate <= new Date() || toDate <= new Date()) {

Â  Â  Â  Â  Â  Â  throw new Error('both dates must be in the future');

Â  Â  Â  Â  }

  

Â  Â  Â  Â  const travelPlan: TravelPlan = {

Â  Â  Â  Â  Â  Â  id: `plan_${this.nextPlanId++}`,

Â  Â  Â  Â  Â  Â  user,

Â  Â  Â  Â  Â  Â  fromCity,

Â  Â  Â  Â  Â  Â  toCity,

Â  Â  Â  Â  Â  Â  fromDate,

Â  Â  Â  Â  Â  Â  toDate,

Â  Â  Â  Â  Â  Â  necessity: { accommodation: true, diningFlag: true } // default necessity

Â  Â  Â  Â  };

  

Â  Â  Â  Â  this.travelPlans.push(travelPlan);

Â  Â  Â  Â  return travelPlan;

Â  Â  }

  

Â  Â  /**

Â  Â  Â * Delete a travel plan and its associated cost estimates

Â  Â  Â * @requires travelPlan exists in system (travelPlan.id found in travelPlans array)

Â  Â  Â * Â  Â  Â  Â  travelPlan.user === user (travel plan must belong to the specified user)

Â  Â  Â * @returns void (no return value)

Â  Â  Â * Â  Â  Â  Â  travelPlan and all associated cost estimates are removed from system

Â  Â  Â */

Â  Â  deleteTravelPlan(user: User, travelPlan: TravelPlan): void {

Â  Â  Â  Â  // Validate requirements

Â  Â  Â  Â  if (!this.travelPlanExists(travelPlan) || travelPlan.user !== user) {

Â  Â  Â  Â  Â  Â  throw new Error('travelPlan must exist and belong to user');

Â  Â  Â  Â  }

  

Â  Â  Â  Â  // Remove associated cost estimates

Â  Â  Â  Â  this.costEstimates = this.costEstimates.filter(estimate => estimate.travelPlanID !== travelPlan.id);

Â  Â  Â  Â  // Remove the travel plan

Â  Â  Â  Â  this.travelPlans = this.travelPlans.filter(plan => plan.id !== travelPlan.id);

Â  Â  }

  

Â  Â  /**

Â  Â  Â * Update necessity preferences for a travel plan

Â  Â  Â * @requires travelPlan exists in system (travelPlan.id found in travelPlans array)

Â  Â  Â * Â  Â  Â  Â  travelPlan.user === user (travel plan must belong to the specified user)

Â  Â  Â * @returns object containing updated travelPlan and necessity with new accommodation and diningFlag values

Â  Â  Â * Â  Â  Â  Â  travelPlan.necessity.accommodation === accommodation

Â  Â  Â * Â  Â  Â  Â  travelPlan.necessity.diningFlag === diningFlag

Â  Â  Â */

Â  Â  updateNecessity(user: User, travelPlan: TravelPlan, accommodation: boolean, diningFlag: boolean): { travelPlan: TravelPlan; necessity: Necessity } {

Â  Â  Â  Â  // Validate requirements

Â  Â  Â  Â  if (!this.travelPlanExists(travelPlan) || travelPlan.user !== user) {

Â  Â  Â  Â  Â  Â  throw new Error('travelPlan must exist and belong to user');

Â  Â  Â  Â  }

  

Â  Â  Â  Â  const necessity: Necessity = { accommodation, diningFlag };

Â  Â  Â  Â  travelPlan.necessity = necessity;

  

Â  Â  Â  Â  return { travelPlan, necessity };

Â  Â  }

  

Â  Â  /**

Â  Â  Â * Reset necessity to default values

Â  Â  Â * @requires travelPlan exists in system (travelPlan.id found in travelPlans array)

Â  Â  Â * Â  Â  Â  Â  travelPlan.user === user (travel plan must belong to the specified user)

Â  Â  Â * @returns void (no return value)

Â  Â  Â * Â  Â  Â  Â  travelPlan.necessity.accommodation === true

Â  Â  Â * Â  Â  Â  Â  travelPlan.necessity.diningFlag === true

Â  Â  Â */

Â  Â  resetNecessity(user: User, travelPlan: TravelPlan): void {

Â  Â  Â  Â  // Validate requirements

Â  Â  Â  Â  if (!this.travelPlanExists(travelPlan) || travelPlan.user !== user) {

Â  Â  Â  Â  Â  Â  throw new Error('travelPlan must exist and belong to user');

Â  Â  Â  Â  }

  

Â  Â  Â  Â  travelPlan.necessity = { accommodation: true, diningFlag: true };

Â  Â  }

  

Â  Â  /**

Â  Â  Â * Generate AI cost estimate using Gemini LLM

Â  Â  Â * @requires travelPlan exists in system (travelPlan.id found in travelPlans array)

Â  Â  Â * Â  Â  Â  Â  travelPlan.user === user (travel plan must belong to the specified user)

Â  Â  Â * Â  Â  Â  Â  llm is a valid GeminiLLM instance

Â  Â  Â * @returns Promise<CostEstimate> with flight, roomsPerNight, foodDaily costs and lastUpdated timestamp

Â  Â  Â * Â  Â  Â  Â  new CostEstimate is stored in system with travelPlan.id as travelPlanID

Â  Â  Â */

Â  Â  async generateAICostEstimate(user: User, travelPlan: TravelPlan, llm: GeminiLLM): Promise<CostEstimate> {

Â  Â  Â  Â  // Validate requirements

Â  Â  Â  Â  if (!this.travelPlanExists(travelPlan) || travelPlan.user !== user) {

Â  Â  Â  Â  Â  Â  throw new Error('travelPlan must exist and belong to user');

Â  Â  Â  Â  }

  

Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  const prompt = this.createCostEstimationPrompt(travelPlan);

Â  Â  Â  Â  Â  Â  const response = await llm.executeLLM(prompt);

Â  Â  Â  Â  Â  Â  const costEstimate = this.parseAndValidateCostEstimate(response, travelPlan.id);

Â  Â  Â  Â  Â  Â  // Store the cost estimate

Â  Â  Â  Â  Â  Â  this.costEstimates.push(costEstimate);

Â  Â  Â  Â  Â  Â  return costEstimate;

Â  Â  Â  Â  } catch (error) {

Â  Â  Â  Â  Â  Â  console.error('Error generating AI cost estimate:', (error as Error).message);

Â  Â  Â  Â  Â  Â  throw error;

Â  Â  Â  Â  }

Â  Â  }

  

Â  Â  /**

Â  Â  Â * Calculate total cost for a travel plan

Â  Â  Â * @requires travelPlan exists in system (travelPlan.id found in travelPlans array)

Â  Â  Â * Â  Â  Â  Â  travelPlan.user === user (travel plan must belong to the specified user)

Â  Â  Â * Â  Â  Â  Â  cost estimate exists for travelPlan (CostEstimate with matching travelPlanID)

Â  Â  Â * @returns number representing total cost (flight + accommodation + food) in USD

Â  Â  Â */

Â  Â  estimateCost(user: User, travelPlan: TravelPlan): number {

Â  Â  Â  Â  const breakdown = this.getCostBreakdown(user, travelPlan);

Â  Â  Â  Â  return breakdown.total;

Â  Â  }

  

Â  Â  /**

Â  Â  Â * Get detailed cost breakdown for a travel plan

Â  Â  Â * @requires travelPlan exists in system (travelPlan.id found in travelPlans array)

Â  Â  Â * Â  Â  Â  Â  travelPlan.user === user (travel plan must belong to the specified user)

Â  Â  Â * Â  Â  Â  Â  cost estimate exists for travelPlan (CostEstimate with matching travelPlanID)

Â  Â  Â * @returns object containing flight cost, total accommodation cost, total food cost, total cost, and duration in days

Â  Â  Â */

Â  Â  getCostBreakdown(user: User, travelPlan: TravelPlan): {

Â  Â  Â  Â  flight: number;

Â  Â  Â  Â  accommodation: number;

Â  Â  Â  Â  food: number;

Â  Â  Â  Â  total: number;

Â  Â  Â  Â  durationDays: number;

Â  Â  } {

Â  Â  Â  Â  // Validate requirements

Â  Â  Â  Â  if (!this.travelPlanExists(travelPlan) || travelPlan.user !== user) {

Â  Â  Â  Â  Â  Â  throw new Error('travelPlan must exist and belong to user');

Â  Â  Â  Â  }

  

Â  Â  Â  Â  const costEstimate = this.getCostEstimate(travelPlan.id);

Â  Â  Â  Â  if (!costEstimate) {

Â  Â  Â  Â  Â  Â  throw new Error('no cost estimate exists for this travel plan');

Â  Â  Â  Â  }

  

Â  Â  Â  Â  // Calculate duration in days

Â  Â  Â  Â  const durationMs = travelPlan.toDate.getTime() - travelPlan.fromDate.getTime();

Â  Â  Â  Â  const durationDays = Math.ceil(durationMs / (1000 * 60 * 60 * 24));

Â  Â  Â  Â  // Calculate individual costs

Â  Â  Â  Â  const flight = costEstimate.flight;

Â  Â  Â  Â  const accommodation = costEstimate.roomsPerNight * durationDays;

Â  Â  Â  Â  const food = costEstimate.foodDaily * durationDays;

Â  Â  Â  Â  const total = flight + accommodation + food;

Â  Â  Â  Â  return {

Â  Â  Â  Â  Â  Â  flight,

Â  Â  Â  Â  Â  Â  accommodation,

Â  Â  Â  Â  Â  Â  food,

Â  Â  Â  Â  Â  Â  total,

Â  Â  Â  Â  Â  Â  durationDays

Â  Â  Â  Â  };

Â  Â  }

  

Â  Â  /**

Â  Â  Â * Helper methods

Â  Â  Â */

Â  Â  /**

Â  Â  Â * Check if a travel plan exists in the system

Â  Â  Â * @requires travelPlan is a valid TravelPlan object

Â  Â  Â * @returns boolean indicating whether travelPlan.id exists in travelPlans array

Â  Â  Â */

Â  Â  private travelPlanExists(travelPlan: TravelPlan): boolean {

Â  Â  Â  Â  return this.travelPlans.some(plan => plan.id === travelPlan.id);

Â  Â  }

  

Â  Â  /**

Â  Â  Â * Get cost estimate by travel plan ID

Â  Â  Â * @requires travelPlanID is a non-empty string

Â  Â  Â * @returns CostEstimate with matching travelPlanID, or undefined if not found

Â  Â  Â */

Â  Â  private getCostEstimate(travelPlanID: string): CostEstimate | undefined {

Â  Â  Â  Â  return this.costEstimates.find(estimate => estimate.travelPlanID === travelPlanID);

Â  Â  }

  

Â  Â  /**

Â  Â  Â * Create the prompt for Gemini AI cost estimation

Â  Â  Â * @requires travelPlan is a valid TravelPlan object

Â  Â  Â * Â  Â  Â  Â  travelPlan.fromDate and travelPlan.toDate are valid Date objects

Â  Â  Â * @returns string containing formatted prompt for Gemini LLM with trip details and instructions

Â  Â  Â */

Â  Â  private createCostEstimationPrompt(travelPlan: TravelPlan): string {

Â  Â  Â  Â  const durationMs = travelPlan.toDate.getTime() - travelPlan.fromDate.getTime();

Â  Â  Â  Â  const durationDays = Math.ceil(durationMs / (1000 * 60 * 60 * 24));

Â  Â  Â  Â  const accommodationText = travelPlan.necessity.accommodation

Â  Â  Â  Â  Â  Â  ? "hotel/motel accommodation"

Â  Â  Â  Â  Â  Â  : "no accommodation needed (staying with friends/family or camping)";

Â  Â  Â  Â  const diningText = travelPlan.necessity.diningFlag

Â  Â  Â  Â  Â  Â  ? "restaurant dining and meals"

Â  Â  Â  Â  Â  Â  : "no dining costs (self-catering or included meals)";

  

Â  Â  Â  Â  return `

You are a helpful AI assistant that provides realistic cost estimates for travel plans.

  

TRIP DETAILS:

- From: ${travelPlan.fromCity.city}

- To: ${travelPlan.toCity.city}

- Duration: ${durationDays} days

- Departure: ${travelPlan.fromDate.toDateString()}

- Return: ${travelPlan.toDate.toDateString()}

  

NECESSITY PREFERENCES:

- Accommodation: ${accommodationText}

- Dining: ${diningText}

  

IMPORTANT INSTRUCTIONS FOR ACCURATE PRICING:

- For MEDIAN flight costs: Use Google Flights to search for round-trip flights between these cities for the specified dates to get current, accurate pricing

- For MEDIAN accommodation costs: Research current hotel/motel prices in the destination city for the specified dates

- For MEDIAN food costs: Research typical daily dining costs in the destination city

  

Please provide realistic cost estimates in USD for:

1. Round-trip flight MEDIAN cost between these cities (use Google Flights for accuracy)

2. MEDIAN Cost per night for accommodation (if accommodation is needed)

3. MEDIAN Daily food/dining costs (if dining is needed)

  

If accommodation is not needed, set rooms per night to 0.

If dining is not needed, set daily food cost to 0.

  

Return your response as a JSON object with this exact structure:

{

Â  "flight": estimated_flight_cost_number,

Â  "roomsPerNight": estimated_room_cost_per_night_number,

Â  "foodDaily": estimated_daily_food_cost_number

}

  

Return ONLY the JSON object, no additional text.`;

Â  Â  }

  

Â  Â  /**

Â  Â  Â * Parse and validate the LLM response

Â  Â  Â * @requires responseText is a non-empty string containing valid JSON

Â  Â  Â * Â  Â  Â  Â  travelPlanID is a non-empty string

Â  Â  Â * Â  Â  Â  Â  JSON contains numeric flight, roomsPerNight, and foodDaily fields

Â  Â  Â * Â  Â  Â  Â  all cost values are within range [MINCOST, MAXCOST]

Â  Â  Â * @returns CostEstimate object with parsed values and current timestamp

Â  Â  Â */

Â  Â  private parseAndValidateCostEstimate(responseText: string, travelPlanID: string): CostEstimate {

Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  // VALIDATOR 1: Check for missing or malformed JSON

Â  Â  Â  Â  Â  Â  this.validateJsonStructure(responseText);

Â  Â  Â  Â  Â  Â  // Extract JSON from response

Â  Â  Â  Â  Â  Â  const jsonMatch = responseText.match(/\{[\s\S]*\}/);

Â  Â  Â  Â  Â  Â  if (!jsonMatch) {

Â  Â  Â  Â  Â  Â  Â  Â  throw new Error('LLM_VALIDATION_ERROR: No JSON object found in response. Expected format: {"flight": number, "roomsPerNight": number, "foodDaily": number}');

Â  Â  Â  Â  Â  Â  }

  

Â  Â  Â  Â  Â  Â  let response: any;

Â  Â  Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  Â  Â  response = JSON.parse(jsonMatch[0]);

Â  Â  Â  Â  Â  Â  } catch (parseError) {

Â  Â  Â  Â  Â  Â  Â  Â  throw new Error('LLM_VALIDATION_ERROR: Invalid JSON format in response. Please ensure the LLM returns valid JSON.');

Â  Â  Â  Â  Â  Â  }

  

Â  Â  Â  Â  Â  Â  // VALIDATOR 2: Check for missing required fields

Â  Â  Â  Â  Â  Â  this.validateRequiredFields(response);

Â  Â  Â  Â  Â  Â  // VALIDATOR 3: Check for unrealistic cost ranges and logical inconsistencies

Â  Â  Â  Â  Â  Â  this.validateCostRangesAndLogic(response);

  

Â  Â  Â  Â  Â  Â  const costEstimate: CostEstimate = {

Â  Â  Â  Â  Â  Â  Â  Â  travelPlanID,

Â  Â  Â  Â  Â  Â  Â  Â  flight: response.flight,

Â  Â  Â  Â  Â  Â  Â  Â  roomsPerNight: response.roomsPerNight,

Â  Â  Â  Â  Â  Â  Â  Â  foodDaily: response.foodDaily,

Â  Â  Â  Â  Â  Â  Â  Â  lastUpdated: new Date()

Â  Â  Â  Â  Â  Â  };

  

Â  Â  Â  Â  Â  Â  return costEstimate;

Â  Â  Â  Â  } catch (error) {

Â  Â  Â  Â  Â  Â  console.error('âŒ LLM Response Validation Error:', (error as Error).message);

Â  Â  Â  Â  Â  Â  console.log('ðŸ“ Raw LLM Response:', responseText);

Â  Â  Â  Â  Â  Â  throw error;

Â  Â  Â  Â  }

Â  Â  }

  

Â  Â  /**

Â  Â  Â * VALIDATOR 1: Validate JSON structure and format

Â  Â  Â * @requires responseText is a non-empty string

Â  Â  Â */

Â  Â  private validateJsonStructure(responseText: string): void {

Â  Â  Â  Â  if (!responseText || responseText.trim().length === 0) {

Â  Â  Â  Â  Â  Â  throw new Error('LLM_VALIDATION_ERROR: Empty response received from LLM');

Â  Â  Â  Â  }

  

Â  Â  Â  Â  // Check for common LLM response issues

Â  Â  Â  Â  if (responseText.includes('```json') && !responseText.includes('```')) {

Â  Â  Â  Â  Â  Â  throw new Error('LLM_VALIDATION_ERROR: Incomplete JSON code block detected. LLM may have been interrupted.');

Â  Â  Â  Â  }

  

Â  Â  Â  Â  if (responseText.includes('I cannot') || responseText.includes('I am unable')) {

Â  Â  Â  Â  Â  Â  throw new Error('LLM_VALIDATION_ERROR: LLM declined to provide estimate. Response contains refusal language.');

Â  Â  Â  Â  }

  

Â  Â  Â  Â  // Check for non-JSON explanatory text that might indicate confusion

Â  Â  Â  Â  const lines = responseText.split('\n').map(line => line.trim()).filter(line => line.length > 0);

Â  Â  Â  Â  const jsonLines = lines.filter(line => line.startsWith('{') || line.includes('"flight"') || line.includes('"roomsPerNight"') || line.includes('"foodDaily"'));

Â  Â  Â  Â  if (jsonLines.length === 0 && lines.length > 3) {

Â  Â  Â  Â  Â  Â  throw new Error('LLM_VALIDATION_ERROR: LLM provided explanatory text but no JSON. Expected pure JSON response.');

Â  Â  Â  Â  }

Â  Â  }

  

Â  Â  /**

Â  Â  Â * VALIDATOR 2: Validate required fields are present and correct type

Â  Â  Â * @requires response is a parsed JSON object

Â  Â  Â */

Â  Â  private validateRequiredFields(response: any): void {

Â  Â  Â  Â  const requiredFields = ['flight', 'roomsPerNight', 'foodDaily'];

Â  Â  Â  Â  const missingFields = requiredFields.filter(field => !(field in response));

Â  Â  Â  Â  if (missingFields.length > 0) {

Â  Â  Â  Â  Â  Â  throw new Error(`LLM_VALIDATION_ERROR: Missing required fields: ${missingFields.join(', ')}. Expected: ${requiredFields.join(', ')}`);

Â  Â  Â  Â  }

  

Â  Â  Â  Â  // Check field types

Â  Â  Â  Â  const typeErrors: string[] = [];

Â  Â  Â  Â  if (typeof response.flight !== 'number') {

Â  Â  Â  Â  Â  Â  typeErrors.push(`flight (expected number, got ${typeof response.flight})`);

Â  Â  Â  Â  }

Â  Â  Â  Â  if (typeof response.roomsPerNight !== 'number') {

Â  Â  Â  Â  Â  Â  typeErrors.push(`roomsPerNight (expected number, got ${typeof response.roomsPerNight})`);

Â  Â  Â  Â  }

Â  Â  Â  Â  if (typeof response.foodDaily !== 'number') {

Â  Â  Â  Â  Â  Â  typeErrors.push(`foodDaily (expected number, got ${typeof response.foodDaily})`);

Â  Â  Â  Â  }

  

Â  Â  Â  Â  if (typeErrors.length > 0) {

Â  Â  Â  Â  Â  Â  throw new Error(`LLM_VALIDATION_ERROR: Incorrect field types: ${typeErrors.join(', ')}`);

Â  Â  Â  Â  }

  

Â  Â  Â  Â  // Check for NaN or Infinity values

Â  Â  Â  Â  const invalidValues: string[] = [];

Â  Â  Â  Â  if (isNaN(response.flight) || !isFinite(response.flight)) {

Â  Â  Â  Â  Â  Â  invalidValues.push('flight');

Â  Â  Â  Â  }

Â  Â  Â  Â  if (isNaN(response.roomsPerNight) || !isFinite(response.roomsPerNight)) {

Â  Â  Â  Â  Â  Â  invalidValues.push('roomsPerNight');

Â  Â  Â  Â  }

Â  Â  Â  Â  if (isNaN(response.foodDaily) || !isFinite(response.foodDaily)) {

Â  Â  Â  Â  Â  Â  invalidValues.push('foodDaily');

Â  Â  Â  Â  }

  

Â  Â  Â  Â  if (invalidValues.length > 0) {

Â  Â  Â  Â  Â  Â  throw new Error(`LLM_VALIDATION_ERROR: Invalid numeric values (NaN/Infinity): ${invalidValues.join(', ')}`);

Â  Â  Â  Â  }

Â  Â  }

  

Â  Â  /**

Â  Â  Â * VALIDATOR 3: Validate cost ranges and logical consistency

Â  Â  Â * @requires response has numeric flight, roomsPerNight, and foodDaily fields

Â  Â  Â */

Â  Â  private validateCostRangesAndLogic(response: any): void {

Â  Â  Â  Â  const { flight, roomsPerNight, foodDaily } = response;

  

Â  Â  Â  Â  // Check for negative values (impossible costs)

Â  Â  Â  Â  const negativeValues: string[] = [];

Â  Â  Â  Â  if (flight < 0) negativeValues.push(`flight (${flight})`);

Â  Â  Â  Â  if (roomsPerNight < 0) negativeValues.push(`roomsPerNight (${roomsPerNight})`);

Â  Â  Â  Â  if (foodDaily < 0) negativeValues.push(`foodDaily (${foodDaily})`);

  

Â  Â  Â  Â  if (negativeValues.length > 0) {

Â  Â  Â  Â  Â  Â  throw new Error(`LLM_VALIDATION_ERROR: Negative costs are impossible: ${negativeValues.join(', ')}`);

Â  Â  Â  Â  }

  

Â  Â  Â  Â  // Check for unreasonably high values (likely hallucination)

Â  Â  Â  Â  const excessiveValues: string[] = [];

Â  Â  Â  Â  if (flight > MAXCOST) excessiveValues.push(`flight (${flight} - exceeds $${MAXCOST.toLocaleString()} limit)`);

Â  Â  Â  Â  if (roomsPerNight > MAXCOST) excessiveValues.push(`roomsPerNight (${roomsPerNight} - exceeds $${MAXCOST.toLocaleString()}/night limit)`);

Â  Â  Â  Â  if (foodDaily > MAXCOST) excessiveValues.push(`foodDaily (${foodDaily} - exceeds $${MAXCOST.toLocaleString()}/day limit)`);

  

Â  Â  Â  Â  if (excessiveValues.length > 0) {

Â  Â  Â  Â  Â  Â  throw new Error(`LLM_VALIDATION_ERROR: Unrealistic excessive costs detected: ${excessiveValues.join(', ')}`);

Â  Â  Â  Â  }

  

Â  Â  Â  Â  // Check for suspiciously low values that might indicate confusion

Â  Â  Â  Â  const suspiciouslyLowValues: string[] = [];

Â  Â  Â  Â  if (flight > 0 && flight < 10) suspiciouslyLowValues.push(`flight (${flight} - suspiciously low for any flight)`);

Â  Â  Â  Â  if (roomsPerNight > 0 && roomsPerNight < 1) suspiciouslyLowValues.push(`roomsPerNight (${roomsPerNight} - suspiciously low for accommodation)`);

Â  Â  Â  Â  if (foodDaily > 0 && foodDaily < 1) suspiciouslyLowValues.push(`foodDaily (${foodDaily} - suspiciously low for daily food costs)`);

  

Â  Â  Â  Â  if (suspiciouslyLowValues.length > 0) {

Â  Â  Â  Â  Â  Â  console.warn(`âš ï¸ Â WARNING: Suspiciously low values detected: ${suspiciouslyLowValues.join(', ')}. Proceeding with caution.`);

Â  Â  Â  Â  }

  

Â  Â  Â  Â  // Check for logical inconsistencies

Â  Â  Â  Â  if (roomsPerNight > flight && flight > 100) {

Â  Â  Â  Â  Â  Â  throw new Error(`LLM_VALIDATION_ERROR: Logical inconsistency - room cost (${roomsPerNight}) exceeds flight cost (${flight}). This suggests LLM confusion.`);

Â  Â  Â  Â  }

  

Â  Â  Â  Â  // Check for decimal precision issues (likely copy-paste errors)

Â  Â  Â  Â  const decimalIssues: string[] = [];

Â  Â  Â  Â  if (flight.toString().split('.')[1]?.length > 2) decimalIssues.push(`flight (${flight} - excessive decimal places)`);

Â  Â  Â  Â  if (roomsPerNight.toString().split('.')[1]?.length > 2) decimalIssues.push(`roomsPerNight (${roomsPerNight} - excessive decimal places)`);

Â  Â  Â  Â  if (foodDaily.toString().split('.')[1]?.length > 2) decimalIssues.push(`foodDaily (${foodDaily} - excessive decimal places)`);

  

Â  Â  Â  Â  if (decimalIssues.length > 0) {

Â  Â  Â  Â  Â  Â  console.warn(`âš ï¸ Â WARNING: Excessive decimal precision detected: ${decimalIssues.join(', ')}. This may indicate LLM confusion.`);

Â  Â  Â  Â  }

Â  Â  }

  

Â  Â  /**

Â  Â  Â * Get travel plan by ID (for testing purposes)

Â  Â  Â * @requires travelPlan is a valid TravelPlan object

Â  Â  Â * @returns TravelPlan with matching ID, or undefined if not found

Â  Â  Â */

Â  Â  getTravelPlan(travelPlan: TravelPlan): TravelPlan | undefined {

Â  Â  Â  Â  return this.travelPlans.find(plan => plan.id === travelPlan.id);

Â  Â  }

  

Â  Â  /**

Â  Â  Â * Get cost estimate by travel plan ID (for testing purposes)

Â  Â  Â * @requires travelPlan is a valid TravelPlan object

Â  Â  Â * @returns CostEstimate with matching travelPlanID, or undefined if not found

Â  Â  Â */

Â  Â  getCostEstimateByPlan(travelPlan: TravelPlan): CostEstimate | undefined {

Â  Â  Â  Â  return this.getCostEstimate(travelPlan.id);

Â  Â  }

}
```

# current TripCostEstimation implementation: 
``` typescript
import { Collection, Db } from "npm:mongodb";

import { ID, Empty } from "@utils/types.ts";

import { freshID } from "@utils/database.ts";

// Import the GeminiLLM. The Config interface is no longer needed here.

import { GeminiLLM } from "@utils/gemini-llm.ts";

  

// Declare collection prefix, use concept name

const PREFIX = "TripCostEstimation" + ".";

  

// Generic types of this concept (all are IDs when referenced as foreign keys)

// These types are now defined at the module level.

type User = ID;

type Location = ID;

type TravelPlan = ID;

type Necessity = ID;

type CostEstimate = ID;

  

/**

Â * Interface for the structured cost estimate output that the LLM is expected to generate.

Â * This defines the target structure for the parsing logic in the Concept class.

Â */

interface CostEstimateResponse {

Â  flight?: number;

Â  roomsPerNight?: number;

Â  foodDaily?: number;

Â  // The `error` field is not part of the *successful* LLM response structure itself,

Â  // but rather part of the action's return type when an error occurs during API call or parsing.

}

  

// --- State Interfaces ---

  

/**

Â * A set of Users

Â * (Documents store the user's ID. TravelPlans link back to User IDs.)

Â */

interface UsersDoc {

Â  _id: User;

Â  // No other properties explicitly defined by the state for a User itself,

Â  // as TravelPlans are linked to Users.

}

  

/**

Â * A set of Locations with

Â * Â  a city String

Â */

interface LocationsDoc {

Â  _id: Location;

Â  city: string;

}

  

/**

Â * A set of TravelPlans with

Â * Â  a `userID` User (Implicitly added for linking TravelPlans to Users)

Â * Â  a `fromCity` Location (ID)

Â * Â  a `toCity` Location (ID)

Â * Â  a `fromDate` Date

Â * Â  a `toDate` Date

Â * Â  a `necessityID` Necessity (ID)

Â */

interface TravelPlansDoc {

Â  _id: TravelPlan;

Â  userID: User; // Link to UsersDoc

Â  fromCity: Location; // Link to LocationsDoc

Â  toCity: Location; // Link to LocationsDoc

Â  fromDate: Date;

Â  toDate: Date;

Â  necessityID: Necessity; // Link to NecessitiesDoc

}

  

/**

Â * A set of Necessities with

Â * Â  an `accommodation` Boolean

Â * Â  a `diningFlag` Boolean

Â */

interface NecessitiesDoc {

Â  _id: Necessity;

Â  accommodation: boolean; // true for saving for rooms, false for not

Â  diningFlag: boolean; // true for saving for eating out, false for not

}

  

/**

Â * A set of CostEstimates with

Â * Â  a `travelPlanID` TravelPlan (ID)

Â * Â  a `flight` Number // estimated total round-trip flight cost in USD

Â * Â  a `roomsPerNight` Number // estimated cost per night in USD

Â * Â  a `foodDaily` Number // estimated cost per day in USD

Â * Â  a `lastUpdated` Date // tracking when the estimate was generated

Â */

interface CostEstimatesDoc {

Â  _id: CostEstimate;

Â  travelPlanID: TravelPlan; // Link to TravelPlansDoc

Â  flight: number; // estimated total round-trip flight cost in USD

Â  roomsPerNight: number; // estimated cost per night in USD

Â  foodDaily: number; // estimated cost per day in USD

Â  lastUpdated: Date; // tracking when the estimate was generated

}

  

/**

Â * @purpose Generate realistic cost estimates based on trip details, using AI for data retrieval and calculation.

Â * @principle Based on a user's choice of initial departure city and arrival city, and the user's sheltering

Â * Â  Â  Â  Â  Â  Â accommodations and food location preferences, an estimate is provided; the LLM is used to search

Â * Â  Â  Â  Â  Â  Â for and calculate median cost ranges based on the provided necessities.

Â */

export default class TripCostEstimationConcept {

Â  // --- MongoDB Collections ---

Â  private users: Collection<UsersDoc>;

Â  private locations: Collection<LocationsDoc>;

Â  private travelPlans: Collection<TravelPlansDoc>;

Â  private necessities: Collection<NecessitiesDoc>;

Â  private costEstimates: Collection<CostEstimatesDoc>;

  

Â  constructor(private readonly db: Db) {

Â  Â  this.users = this.db.collection(PREFIX + "users");

Â  Â  this.locations = this.db.collection(PREFIX + "locations");

Â  Â  this.travelPlans = this.db.collection(PREFIX + "travelPlans");

Â  Â  this.necessities = this.db.collection(PREFIX + "necessities");

Â  Â  this.costEstimates = this.db.collection(PREFIX + "costEstimates");

Â  }

  

Â  // --- Private Helper Methods ---

  

Â  /**

Â  Â * Parses the LLM's raw string response into a structured CostEstimateResponse object.

Â  Â * Assumes the LLM response is a JSON string, potentially wrapped in markdown.

Â  Â * This method is now private to the concept, enforcing separation of concerns

Â  Â * between LLM interaction and domain-specific parsing.

Â  Â * @param rawResponse The raw string output received from the LLM.

Â  Â * @returns CostEstimateResponse if parsing is successful, or an object with an `error` string.

Â  Â */

Â  private _parseLLMCostEstimate(

Â  Â  rawResponse: string,

Â  ): CostEstimateResponse | { error: string } {

Â  Â  try {

Â  Â  Â  let jsonString = rawResponse.trim();

  

Â  Â  Â  // Attempt to remove markdown code block wrappers if present

Â  Â  Â  if (jsonString.startsWith("```json") && jsonString.endsWith("```")) {

Â  Â  Â  Â  jsonString = jsonString.substring(7, jsonString.length - 3).trim();

Â  Â  Â  } else if (jsonString.startsWith("```") && jsonString.endsWith("```")) {

Â  Â  Â  Â  jsonString = jsonString.substring(3, jsonString.length - 3).trim();

Â  Â  Â  }

  

Â  Â  Â  const parsed = JSON.parse(jsonString);

  

Â  Â  Â  if (typeof parsed !== "object" || parsed === null) {

Â  Â  Â  Â  throw new Error("LLM response is not a valid JSON object.");

Â  Â  Â  }

  

Â  Â  Â  const costEstimate: CostEstimateResponse = {};

Â  Â  Â  if (typeof parsed.flight === "number") costEstimate.flight = parsed.flight;

Â  Â  Â  if (typeof parsed.roomsPerNight === "number") {

Â  Â  Â  Â  costEstimate.roomsPerNight = parsed.roomsPerNight;

Â  Â  Â  }

Â  Â  Â  if (typeof parsed.foodDaily === "number") costEstimate.foodDaily = parsed.foodDaily;

  

Â  Â  Â  // Log warnings for unexpected types but still return what was successfully parsed

Â  Â  Â  if (parsed.flight !== undefined && typeof parsed.flight !== "number") {

Â  Â  Â  Â  console.warn("LLM response 'flight' field is not a number:", parsed.flight);

Â  Â  Â  }

Â  Â  Â  if (

Â  Â  Â  Â  parsed.roomsPerNight !== undefined &&

Â  Â  Â  Â  typeof parsed.roomsPerNight !== "number"

Â  Â  Â  ) {

Â  Â  Â  Â  console.warn(

Â  Â  Â  Â  Â  "LLM response 'roomsPerNight' field is not a number:",

Â  Â  Â  Â  Â  parsed.roomsPerNight,

Â  Â  Â  Â  );

Â  Â  Â  }

Â  Â  Â  if (parsed.foodDaily !== undefined && typeof parsed.foodDaily !== "number") {

Â  Â  Â  Â  console.warn(

Â  Â  Â  Â  Â  "LLM response 'foodDaily' field is not a number:",

Â  Â  Â  Â  Â  parsed.foodDaily,

Â  Â  Â  Â  );

Â  Â  Â  }

  

Â  Â  Â  // Check if any *expected* fields are missing or invalid after parsing,

Â  Â  Â  // and if so, return an error. The prompt explicitly asks for these.

Â  Â  Â  if (

Â  Â  Â  Â  costEstimate.flight === undefined ||

Â  Â  Â  Â  costEstimate.roomsPerNight === undefined ||

Â  Â  Â  Â  costEstimate.foodDaily === undefined

Â  Â  Â  ) {

Â  Â  Â  Â  // If at least one of the primary expected cost fields is missing/invalid,

Â  Â  Â  Â  // consider the parsing unsuccessful for a full estimate.

Â  Â  Â  Â  return {

Â  Â  Â  Â  Â  error:

Â  Â  Â  Â  Â  Â  `LLM response could not be parsed into all required cost components (flight, roomsPerNight, foodDaily). Raw: ${jsonString}`,

Â  Â  Â  Â  };

Â  Â  Â  }

  

Â  Â  Â  return costEstimate;

Â  Â  } catch (e) {

Â  Â  Â  console.error("Failed to parse LLM response:", rawResponse, e);

Â  Â  Â  return { error: `Failed to parse LLM response into expected JSON format: ${(e as Error).message}` };

Â  Â  }

Â  }

  

Â  // --- Actions ---

  

Â  /**

Â  Â * createTravelPlan (user: User, fromCity: Location, toCity: Location, fromDate: Date, toDate: Date): (travelPlan: TravelPlan)

Â  Â *

Â  Â * **requires** `fromCity` and `toCity` exists and `toDate` >= `fromDate` and both are greater than the current date

Â  Â *

Â  Â * **effects** Create and return a `travelPlan` with a `fromCity`, `toCity`, and from and to dates, and a default necessity (`accommodation` = true, `diningFlag` = true)

Â  Â */

Â  async createTravelPlan(

Â  Â  {

Â  Â  Â  user,

Â  Â  Â  fromCity,

Â  Â  Â  toCity,

Â  Â  Â  fromDate,

Â  Â  Â  toDate,

Â  Â  }: {

Â  Â  Â  user: ID;

Â  Â  Â  fromCity: ID;

Â  Â  Â  toCity: ID;

Â  Â  Â  fromDate: Date;

Â  Â  Â  toDate: Date;

Â  Â  },

Â  ): Promise<{ travelPlan: ID } | { error: string }> {

Â  Â  // Requires: fromCity and toCity exist

Â  Â  const origin = await this.locations.findOne({ _id: fromCity });

Â  Â  const destination = await this.locations.findOne({ _id: toCity });

  

Â  Â  if (!origin) {

Â  Â  Â  return { error: `Origin city with ID ${fromCity} not found.` };

Â  Â  }

Â  Â  if (!destination) {

Â  Â  Â  return { error: `Destination city with ID ${toCity} not found.` };

Â  Â  }

  

Â  Â  // Requires: toDate >= fromDate

Â  Â  if (toDate < fromDate) {

Â  Â  Â  return { error: "Arrival date must be on or after departure date." };

Â  Â  }

  

Â  Â  // Requires: both dates are greater than the current date

Â  Â  const now = new Date();

Â  Â  now.setHours(0, 0, 0, 0); // Normalize to start of day for comparison

Â  Â  if (fromDate < now || toDate < now) {

Â  Â  Â  return { error: "Departure and arrival dates must be in the future." };

Â  Â  }

  

Â  Â  // Ensure the user exists (or create a placeholder if not found, depending on domain logic)

Â  Â  await this.users.updateOne(

Â  Â  Â  { _id: user },

Â  Â  Â  { $setOnInsert: { _id: user } },

Â  Â  Â  { upsert: true },

Â  Â  );

  

Â  Â  // Create default Necessity

Â  Â  const newNecessityID = freshID();

Â  Â  const newNecessity: NecessitiesDoc = {

Â  Â  Â  _id: newNecessityID,

Â  Â  Â  accommodation: true,

Â  Â  Â  diningFlag: true,

Â  Â  };

Â  Â  await this.necessities.insertOne(newNecessity);

  

Â  Â  // Create TravelPlan

Â  Â  const newTravelPlanID = freshID();

Â  Â  const newTravelPlan: TravelPlansDoc = {

Â  Â  Â  _id: newTravelPlanID,

Â  Â  Â  userID: user,

Â  Â  Â  fromCity: fromCity,

Â  Â  Â  toCity: toCity,

Â  Â  Â  fromDate: fromDate,

Â  Â  Â  toDate: toDate,

Â  Â  Â  necessityID: newNecessityID,

Â  Â  };

Â  Â  await this.travelPlans.insertOne(newTravelPlan);

  

Â  Â  return { travelPlan: newTravelPlanID };

Â  }

  

Â  /**

Â  Â * deleteTravelPlan (user: User, travelPlan: TravelPlan): Empty

Â  Â *

Â  Â * **requires** `travelPlan` exists and belongs to user

Â  Â *

Â  Â * **effects** Delete the `travelPlan` and any associated `CostEstimates` and `Necessities`

Â  Â */

Â  async deleteTravelPlan(

Â  Â  { user, travelPlan }: { user: ID; travelPlan: ID },

Â  ): Promise<Empty | { error: string }> {

Â  Â  const existingTravelPlan = await this.travelPlans.findOne({

Â  Â  Â  _id: travelPlan,

Â  Â  Â  userID: user,

Â  Â  });

  

Â  Â  if (!existingTravelPlan) {

Â  Â  Â  return {

Â  Â  Â  Â  error: "Travel plan not found or does not belong to the user.",

Â  Â  Â  };

Â  Â  }

  

Â  Â  // Delete associated CostEstimates

Â  Â  await this.costEstimates.deleteMany({ travelPlanID: travelPlan });

  

Â  Â  // Delete associated Necessity

Â  Â  await this.necessities.deleteOne({ _id: existingTravelPlan.necessityID });

  

Â  Â  // Delete the TravelPlan itself

Â  Â  await this.travelPlans.deleteOne({ _id: travelPlan });

  

Â  Â  return {};

Â  }

  

Â  /**

Â  Â * updateNecessity (user: User, travelPlan: TravelPlan, accommodation: Boolean, diningFlag: Boolean): (travelPlan: TravelPlan, necessity: Necessity)

Â  Â *

Â  Â * **requires** `travelPlan` exists and belongs to user

Â  Â *

Â  Â * **effects** Create and add the `necessity` with `accommodation` and `diningFlag` to `travelPlan` (updates existing necessity)

Â  Â */

Â  async updateNecessity(

Â  Â  {

Â  Â  Â  user,

Â  Â  Â  travelPlan,

Â  Â  Â  accommodation,

Â  Â  Â  diningFlag,

Â  Â  }: {

Â  Â  Â  user: ID;

Â  Â  Â  travelPlan: ID;

Â  Â  Â  accommodation: boolean;

Â  Â  Â  diningFlag: boolean;

Â  Â  },

Â  ): Promise<{ travelPlan: ID; necessity: ID } | { error: string }> {

Â  Â  const existingTravelPlan = await this.travelPlans.findOne({

Â  Â  Â  _id: travelPlan,

Â  Â  Â  userID: user,

Â  Â  });

  

Â  Â  if (!existingTravelPlan) {

Â  Â  Â  return {

Â  Â  Â  Â  error: "Travel plan not found or does not belong to the user.",

Â  Â  Â  };

Â  Â  }

  

Â  Â  const updateResult = await this.necessities.updateOne(

Â  Â  Â  { _id: existingTravelPlan.necessityID },

Â  Â  Â  { $set: { accommodation: accommodation, diningFlag: diningFlag } },

Â  Â  );

  

Â  Â  if (updateResult.matchedCount === 0) {

Â  Â  Â  // This should ideally not happen if travelPlan.necessityID is always valid

Â  Â  Â  return { error: "Associated necessity not found." };

Â  Â  }

  

Â  Â  return {

Â  Â  Â  travelPlan: travelPlan,

Â  Â  Â  necessity: existingTravelPlan.necessityID,

Â  Â  };

Â  }

  

Â  /**

Â  Â * resetNecessity (user: User, travelPlan: TravelPlan): Empty

Â  Â *

Â  Â * **requires** `travelPlan` exists and belongs to user

Â  Â *

Â  Â * **effects** Reset the `necessity` belonging to `travelPlan` to the default as described in the action `createTravelPlan`

Â  Â */

Â  async resetNecessity(

Â  Â  { user, travelPlan }: { user: ID; travelPlan: ID },

Â  ): Promise<Empty | { error: string }> {

Â  Â  const existingTravelPlan = await this.travelPlans.findOne({

Â  Â  Â  _id: travelPlan,

Â  Â  Â  userID: user,

Â  Â  });

  

Â  Â  if (!existingTravelPlan) {

Â  Â  Â  return {

Â  Â  Â  Â  error: "Travel plan not found or does not belong to the user.",

Â  Â  Â  };

Â  Â  }

  

Â  Â  const updateResult = await this.necessities.updateOne(

Â  Â  Â  { _id: existingTravelPlan.necessityID },

Â  Â  Â  { $set: { accommodation: true, diningFlag: true } }, // Default values

Â  Â  );

  

Â  Â  if (updateResult.matchedCount === 0) {

Â  Â  Â  return { error: "Associated necessity not found." };

Â  Â  }

  

Â  Â  return {};

Â  }

  

Â  /**

Â  Â * generateAICostEstimate (user: User, travelPlan: TravelPlan, llm: GeminiLLM): (costEstimate: CostEstimate)

Â  Â *

Â  Â * **requires** `travelPlan` exists and belongs to user

Â  Â *

Â  Â * **effects** Retrieves trip details (dates, locations) and necessity preference (accommodation, dining) and uses the llm's specialized tool (e.g., Google Search/Flights/Hotels) to calculate and return the median cost estimates for flight, `rooms_per_night`, and `food_daily`; the resulting data is stored as a new `CostEstimate` associated with the `travelPlanID`.

Â  Â * **Note:** The LLM prompt will be specifically tailored to search for accommodation prices matching the `accommodation` Boolean (e.g., true for hotel/motel costs) and food costs based on the `diningFlag` (true for "restaurant costs," false for "no food costs"). If the LLM fails to provide an estimate for any reason or the costs are widely inaccurate (less than 50, more than 100000 for example) then the user can manually enter the total cost of the trip that they plan to save for.

Â  Â */

Â  async generateAICostEstimate(

Â  Â  { user, travelPlan, llm }: { user: ID; travelPlan: ID; llm: GeminiLLM }, // `llm` type is now `GeminiLLM`

Â  ): Promise<{ costEstimate: ID } | { error: string }> {

Â  Â  const existingTravelPlan = await this.travelPlans.findOne({

Â  Â  Â  _id: travelPlan,

Â  Â  Â  userID: user,

Â  Â  });

  

Â  Â  if (!existingTravelPlan) {

Â  Â  Â  return {

Â  Â  Â  Â  error: "Travel plan not found or does not belong to the user.",

Â  Â  Â  };

Â  Â  }

  

Â  Â  const [originCityDoc, destinationCityDoc, necessityDoc] = await Promise.all(

Â  Â  Â  [

Â  Â  Â  Â  this.locations.findOne({ _id: existingTravelPlan.fromCity }),

Â  Â  Â  Â  this.locations.findOne({ _id: existingTravelPlan.toCity }),

Â  Â  Â  Â  this.necessities.findOne({ _id: existingTravelPlan.necessityID }),

Â  Â  Â  ],

Â  Â  );

  

Â  Â  if (!originCityDoc || !destinationCityDoc || !necessityDoc) {

Â  Â  Â  return { error: "Referenced location or necessity data not found." };

Â  Â  }

  

Â  Â  const numNights = Math.ceil(

Â  Â  Â  (existingTravelPlan.toDate.getTime() -

Â  Â  Â  Â  existingTravelPlan.fromDate.getTime()) /

Â  Â  Â  Â  (1000 * 60 * 60 * 24),

Â  Â  );

Â  Â  const fromDateStr = existingTravelPlan.fromDate.toISOString().split("T")[0];

Â  Â  const toDateStr = existingTravelPlan.toDate.toISOString().split("T")[0];

  

Â  Â  const accommodationPreference = necessityDoc.accommodation

Â  Â  Â  ? "hotel/motel costs"

Â  Â  Â  : "no accommodation costs (e.g., staying with friends/family)";

Â  Â  const diningPreference = necessityDoc.diningFlag

Â  Â  Â  ? "daily restaurant food costs"

Â  Â  Â  : "no food costs (e.g., cooking own meals)";

  

Â  Â  // Prompt explicitly asks for JSON, as the LLM utility is configured for it.

Â  Â  const prompt =

Â  Â  Â  `Please provide a cost estimate in JSON format for a trip. ` +

Â  Â  Â  `Estimate median round-trip flight, ${

Â  Â  Â  Â  accommodationPreference

Â  Â  Â  }, and ${diningPreference} ` +

Â  Â  Â  `from ${originCityDoc.city} to ${destinationCityDoc.city} ` +

Â  Â  Â  `departing on ${fromDateStr} and returning on ${toDateStr} ` +

Â  Â  Â  `for a trip lasting approximately ${numNights} nights. ` +

Â  Â  Â  `The JSON object should have the structure: ` +

Â  Â  Â  `{"flight": <number>, "roomsPerNight": <number>, "foodDaily": <number>}. ` +

Â  Â  Â  `Return only the JSON object.`;

  

Â  Â  let llmRawResult: string;

Â  Â  try {

Â  Â  Â  llmRawResult = await llm.executeLLM(prompt);

Â  Â  } catch (llmError) {

Â  Â  Â  // Catch errors thrown by GeminiLLM.executeLLM

Â  Â  Â  return { error: `LLM API call failed: ${(llmError as Error).message}` };

Â  Â  }

  

Â  Â  // Parse the raw LLM response using the private method in the concept.

Â  Â  const parsedCostEstimate = this._parseLLMCostEstimate(llmRawResult);

  

Â  Â  if ("error" in parsedCostEstimate) {

Â  Â  Â  return { error: parsedCostEstimate.error };

Â  Â  }

  

Â  Â  const flightCost = parsedCostEstimate.flight ?? 0;

Â  Â  const roomsPerNightCost = parsedCostEstimate.roomsPerNight ?? 0;

Â  Â  const foodDailyCost = parsedCostEstimate.foodDaily ?? 0;

  

Â  Â  // Basic validation for wide inaccuracies

Â  Â  if (

Â  Â  Â  flightCost < 50 || flightCost > 100000 ||

Â  Â  Â  roomsPerNightCost < 0 || roomsPerNightCost > 5000 ||

Â  Â  Â  foodDailyCost < 0 || foodDailyCost > 1000

Â  Â  ) {

Â  Â  Â  return {

Â  Â  Â  Â  error:

Â  Â  Â  Â  Â  "LLM provided cost estimates are widely inaccurate or outside reasonable bounds. Please consider manual input.",

Â  Â  Â  };

Â  Â  }

  

Â  Â  const newCostEstimateID = freshID();

Â  Â  const newCostEstimate: CostEstimatesDoc = {

Â  Â  Â  _id: newCostEstimateID,

Â  Â  Â  travelPlanID: travelPlan,

Â  Â  Â  flight: flightCost,

Â  Â  Â  roomsPerNight: roomsPerNightCost,

Â  Â  Â  foodDaily: foodDailyCost,

Â  Â  Â  lastUpdated: new Date(),

Â  Â  };

  

Â  Â  // Replace any existing estimate for this travel plan

Â  Â  await this.costEstimates.replaceOne(

Â  Â  Â  { travelPlanID: travelPlan },

Â  Â  Â  newCostEstimate,

Â  Â  Â  { upsert: true },

Â  Â  );

  

Â  Â  return { costEstimate: newCostEstimateID };

Â  }

  

Â  /**

Â  Â * estimateCost (user: User, travelPlan: TravelPlan): (totalCost: Number)

Â  Â *

Â  Â * **requires** `travelPlan` exists and belongs to user and an associated `CostEstimate` exists

Â  Â *

Â  Â * **effects** Calculates and returns the `totalCost` by multiplying the estimated daily/nightly costs by the duration and adding the flight cost.

Â  Â */

Â  async estimateCost(

Â  Â  { user, travelPlan }: { user: ID; travelPlan: ID },

Â  ): Promise<{ totalCost: number } | { error: string }> {

Â  Â  const existingTravelPlan = await this.travelPlans.findOne({

Â  Â  Â  _id: travelPlan,

Â  Â  Â  userID: user,

Â  Â  });

  

Â  Â  if (!existingTravelPlan) {

Â  Â  Â  return {

Â  Â  Â  Â  error: "Travel plan not found or does not belong to the user.",

Â  Â  Â  };

Â  Â  }

  

Â  Â  const costEstimate = await this.costEstimates.findOne({

Â  Â  Â  travelPlanID: travelPlan,

Â  Â  });

  

Â  Â  if (!costEstimate) {

Â  Â  Â  return { error: "No cost estimate found for this travel plan." };

Â  Â  }

  

Â  Â  // Calculate number of days (inclusive of arrival day if departing on same day as arrival, min 1 day)

Â  Â  const numDays = Math.max(

Â  Â  Â  1, // Ensure at least 1 day for calculation if fromDate and toDate are the same

Â  Â  Â  Math.ceil(

Â  Â  Â  Â  (existingTravelPlan.toDate.getTime() -

Â  Â  Â  Â  Â  existingTravelPlan.fromDate.getTime()) /

Â  Â  Â  Â  Â  (1000 * 60 * 60 * 24),

Â  Â  Â  ),

Â  Â  );

  

Â  Â  // Assuming numDays also represents nights for roomsPerNight for simplification

Â  Â  // For more accuracy, one might adjust `numNights` for accommodation calculations:

Â  Â  // `numNights = Math.max(0, Math.floor((toDate.getTime() - fromDate.getTime()) / (1000 * 60 * 60 * 24)))`

Â  Â  // However, the problem statement uses 'numNights' as the duration for the prompt,

Â  Â  // and 'roomsPerNight' is often calculated based on full nights stay.

Â  Â  // Sticking to `numDays` for both for consistency with earlier `numNights` calculation in `generateAICostEstimate`.

Â  Â  const totalCost = costEstimate.flight +

Â  Â  Â  (costEstimate.roomsPerNight * numDays) +

Â  Â  Â  (costEstimate.foodDaily * numDays);

  

Â  Â  return { totalCost: totalCost };

Â  }

  

Â  // --- Queries ---

  

Â  /**

Â  Â * _getAllTravelPlans (user: User): (travelPlans: TravelPlan[])

Â  Â *

Â  Â * **requires** `user` exists

Â  Â *

Â  Â * **effects** Returns a list of all `TravelPlan` IDs associated with the given `user`.

Â  Â */

Â  async _getAllTravelPlans(

Â  Â  { user }: { user: ID },

Â  ): Promise<TravelPlan[] | { error: string }[]> { // Changed return type to TravelPlan[]

Â  Â  // Check if user exists (as per "requires" clause).

Â  Â  // If user doesn't exist, return an error as specified for typical error handling.

Â  Â  const userExists = await this.users.findOne({ _id: user });

Â  Â  if (!userExists) {

Â  Â  Â  return [{ error: `User with ID ${user} does not exist.` }];

Â  Â  }

  

Â  Â  // Project only the _id field

Â  Â  const plans = await this.travelPlans.find({ userID: user }, {

Â  Â  Â  projection: { _id: 1 },

Â  Â  }).toArray();

  

Â  Â  // Map to an array of TravelPlan IDs (which are of type ID)

Â  Â  return plans.map((plan: TravelPlansDoc) => plan._id as TravelPlan); // Explicitly cast to TravelPlan for type safety

Â  }

}
```

